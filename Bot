from telegram.ext import Application, CommandHandler, MessageHandler, filters as Filters, CallbackQueryHandler, CallbackContext
from telegram import Update, ForceReply, InlineKeyboardButton, InlineKeyboardMarkup
from typing import Union

TOKEN = '6105377507:AAHzMBoQx1sWo2g8ICwxQRJSKpCVlfSUYtc'

pizza_dict = {
    'Cheese': {'name': ' 🧀 Сырная', 'price': 400},
    'Carbonara': {'name': ' 🥩 Карбонара', 'price': 500},
    'Dodo': {'name': ' 🥓 Додо', 'price': 650},
    'Homelike': {'name': ' 🍲 Домашняя', 'price': 350},
}

size_dict = {
    'small': {'name': '📍 30 см', 'price_multiplier': 1},
    'medium': {'name': '📍 40 см', 'price_multiplier': 1.5},
    'large': {'name': '📍 50 см', 'price_multiplier': 2},
}

async def create_pizza_keyboard(buttons_per_row=2):
    keyboard = []
    row = []

    for pizza_key, pizza_info in pizza_dict.items():
        row.append(
            InlineKeyboardButton(pizza_info['name'], callback_data=f'pizza_{pizza_key}')
        )

        if len(row) == buttons_per_row:
            keyboard.append(row)
            row = []

    if row:
        keyboard.append(row)

    return InlineKeyboardMarkup(keyboard)

async def create_size_keyboard(buttons_per_row=2):
    keyboard = []
    row = []

    for size_key, size_info in size_dict.items():
        row.append(
            InlineKeyboardButton(size_info['name'], callback_data=f'size_{size_key}')
        )

        if len(row) == buttons_per_row:
            keyboard.append(row)
            row = []

    if row:
        keyboard.append(row)

    return InlineKeyboardMarkup(keyboard)

async def start(update: Update, context: Union[CallbackContext, None]) -> None:
    user = update.effective_user
    await update.message.reply_markdown_v2(
        fr'Здравствуйте дорогой клиент🤚 , {user.mention_markdown_v2()}',
        reply_markup=ForceReply(selective=True),
    )

async def echo(update: Update, context: Union[CallbackContext, None]) -> None:
    if context.user_data.get('awaiting_address', False):
        await address(update, context)
    else:
        reply_markup = await create_pizza_keyboard()
        await update.message.reply_text(text='Выберите пиццу 👇:', reply_markup=reply_markup)

async def button(update: Update, context: Union[CallbackContext, None]) -> None:
    query = update.callback_query
    data_parts = query.data.split('_')

    if data_parts[0] == 'pizza':
        context.user_data['selected_pizza'] = data_parts[1]
        reply_markup = await create_size_keyboard()
        reply_text = 'Какой размер пиццы вас интересует 😏:'
    elif data_parts[0] == 'size':
        context.user_data['selected_size'] = data_parts[1]
        reply_text = 'Укажите адрес доставки ✏:'
        reply_markup = ForceReply(selective=True)
        await context.bot.send_message(chat_id=update.effective_chat.id, text=reply_text, reply_markup=reply_markup)
        await query.answer()
        context.user_data['awaiting_address'] = True
        return
    else:
        reply_text = '😟 Что-то пошло не так, повторите свой заказ.'
        reply_markup = None
    
    await query.edit_message_text(text=reply_text, reply_markup=reply_markup)
    await query.answer()

async def address(update: Update, context: Union[CallbackContext, None]) -> None:
    address = update.message.text
    selected_pizza = pizza_dict[context.user_data['selected_pizza']]
    selected_size = size_dict[context.user_data['selected_size']]

    price = selected_pizza['price'] * selected_size['price_multiplier']
    reply_text = f'❤ Спасибо за заказ.\n🤤 Пицца:{selected_pizza["name"]},\n📏 Размер:{selected_size["name"]}\n📫 Адрес: {address}\n💰 Цена: {price} руб.'
    context.user_data['awaiting_address'] = False

    await update.message.reply_text(text=reply_text)

def main() -> None:
    application = Application.builder().token(TOKEN).build()

    application.add_handler(CommandHandler('start', start))
    application.add_handler(MessageHandler(Filters.TEXT & ~Filters.COMMAND, echo))
    application.add_handler(CallbackQueryHandler(button))
    application.add_handler(MessageHandler(Filters.REPLY & Filters.TEXT, address))

    application.run_polling()

if __name__ == '__main__':
    main()
